'use client';

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Input, Button, Space, Upload, Spin, App } from 'antd';
import { SendOutlined, PaperClipOutlined, RobotOutlined, CloseOutlined } from '@ant-design/icons';
import { useTranslation } from 'react-i18next';
import { v4 as uuidv4 } from 'uuid';
import { Message, FileAttachment, CurrentFileInfo } from '@/lib/types/chat';
import claudeCodeService, { type StreamEvent } from '@/lib/services/claudeCodeService';
import { useProject } from '@/lib/providers/project-provider';
import type { SDKMessage } from '@anthropic-ai/claude-code';
import MessageBubble, { type ToolActivity } from './MessageBubble';

const { TextArea } = Input;

interface ChatPanelProps {
  darkMode?: boolean;
  className?: string;
}

// ç§»é™¤é‡è¤‡å®šç¾©ï¼Œç›´æ¥ä½¿ç”¨å°å…¥çš„ CurrentFileInfo

export const ChatPanel: React.FC<ChatPanelProps> = ({ darkMode = false, className }) => {
  const { t } = useTranslation();
  const { getCurrentBasePath } = useProject();
  const { message } = App.useApp();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [attachments, setAttachments] = useState<FileAttachment[]>([]);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);
  const [currentAssistantMessage, setCurrentAssistantMessage] = useState<string>('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [isThinking, setIsThinking] = useState(false);
  const [toolActivities, setToolActivities] = useState<Map<string, ToolActivity[]>>(new Map());
  
  // Tool Activities è¨˜æ†¶é«”ç®¡ç†é…ç½®
  const MAX_TOOL_ACTIVITIES_SIZE = 50; // æœ€å¤šä¿ç•™ 50 å€‹è¨Šæ¯çš„å·¥å…·æ´»å‹•
  const CLEANUP_THRESHOLD = 60; // ç•¶è¶…é 60 å€‹æ™‚è§¸ç™¼æ¸…ç†
  
  // æ¸…ç† Tool Activities è¨˜æ†¶é«”
  const cleanupToolActivities = useCallback((currentMap: Map<string, ToolActivity[]>) => {
    if (currentMap.size <= MAX_TOOL_ACTIVITIES_SIZE) {
      return currentMap;
    }
    
    // è½‰æ›ç‚ºé™£åˆ—ä¸¦æŒ‰æ™‚é–“æˆ³æ’åº (ä¿ç•™æœ€æ–°çš„)
    const entries = Array.from(currentMap.entries());
    const sortedEntries = entries.sort((a, b) => {
      const aLatestTime = Math.max(...a[1].map(activity => activity.timestamp.getTime()));
      const bLatestTime = Math.max(...b[1].map(activity => activity.timestamp.getTime()));
      return bLatestTime - aLatestTime; // é™åºï¼Œæœ€æ–°çš„åœ¨å‰é¢
    });
    
    // åªä¿ç•™æœ€æ–°çš„ MAX_TOOL_ACTIVITIES_SIZE å€‹
    const keptEntries = sortedEntries.slice(0, MAX_TOOL_ACTIVITIES_SIZE);
    const cleanedMap = new Map(keptEntries);
    
    console.log(`[ChatPanel] Cleaned tool activities: ${currentMap.size} â†’ ${cleanedMap.size}`);
    return cleanedMap;
  }, [MAX_TOOL_ACTIVITIES_SIZE]);
  
  // å®‰å…¨çš„ Tool Activities æ›´æ–°å‡½æ•¸ (å¸¶è¨˜æ†¶é«”ç®¡ç†)
  const updateToolActivities = useCallback((updater: (prev: Map<string, ToolActivity[]>) => Map<string, ToolActivity[]>) => {
    setToolActivities(prev => {
      const updated = updater(prev);
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†
      if (updated.size >= CLEANUP_THRESHOLD) {
        return cleanupToolActivities(updated);
      }
      
      return updated;
    });
  }, [CLEANUP_THRESHOLD, cleanupToolActivities]);
  const [currentAssistantMessageId, setCurrentAssistantMessageId] = useState<string>('');
  const [currentFile, setCurrentFile] = useState<CurrentFileInfo | null>(null);
  const [hasSentFirstMessage, setHasSentFirstMessage] = useState(false); // è¿½è¹¤æ˜¯å¦å·²ç™¼é€ç¬¬ä¸€æ¬¡è¨Šæ¯
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<File[]>([]);
  const claudeSessionRef = useRef<string | null>(null); // å„²å­˜ Claude SDK çš„çœŸå¯¦ session ID

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, currentAssistantMessage]);

  // åˆå§‹åŒ–å°è©±æ­·å²å’Œè¼‰å…¥æ­·å²è¨Šæ¯
  useEffect(() => {
    const initializeChat = async () => {
      const currentProject = getCurrentBasePath();
      if (currentProject) {
        // åœ¨æ–°æ¶æ§‹ä¸­ï¼Œæ¯æ¬¡é é¢è¼‰å…¥éƒ½æœƒè‡ªå‹•å‰µå»ºæ–°çš„ç¨ç«‹ session
        // session ID ç”± Claude SDK å‹•æ…‹ç”Ÿæˆï¼Œä¸éœ€è¦é å…ˆç”¢ç”Ÿ
        console.log('[ChatPanel] Initialize with new architecture');
        console.log('[ChatPanel] Session ID will be generated by Claude SDK on first query');
        console.log('[ChatPanel] Each tab/reload automatically creates isolated session');
        
        // åˆå§‹åŒ–ç‚ºç©ºæ¶ˆæ¯æ­·å²ï¼Œè®“æ–°å°è©±å¾é ­é–‹å§‹
        setMessages([]);
        
        // æ¸…ç†ä¸å†éœ€è¦çš„ sessionStorage é …ç›®
        sessionStorage.removeItem('pageRefreshed');
        sessionStorage.removeItem('isNewWindow');
        sessionStorage.removeItem('windowId');
      }
    };
    
    initializeChat();
  }, [getCurrentBasePath]);

  // ç›£è½ä¾†è‡ªçˆ¶è¦–çª—çš„æª”æ¡ˆé¸æ“‡äº‹ä»¶
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // æª¢æŸ¥è¨Šæ¯ä¾†æºå’Œé¡å‹
      if (event.data?.type === 'fileSelected' && event.data?.file) {
        const fileInfo = event.data.file as CurrentFileInfo;
        setCurrentFile(fileInfo);
        console.log('[ChatPanel] Received file selection:', fileInfo.path);
      }
    };

    // ç›£è½ postMessage äº‹ä»¶
    window.addEventListener('message', handleMessage);
    
    // æ¸…ç†ç›£è½å™¨
    return () => {
      window.removeEventListener('message', handleMessage);
    };
  }, []);

  // æª¢æŸ¥èªè­‰ç‹€æ…‹
  useEffect(() => {
    const checkAuth = async () => {
      const authStatus = await claudeCodeService.checkAuthentication();
      setIsAuthenticated(authStatus);
    };
    checkAuth();
  }, []);

  // ç›£è½å°ˆæ¡ˆåˆ‡æ›äº‹ä»¶ï¼Œæ¸…ç©ºå°è©±å…§å®¹
  useEffect(() => {
    const handleProjectChange = () => {
      setMessages([]);
      setCurrentAssistantMessage('');
      setIsStreaming(false);
      setIsThinking(false);
      setToolActivities(new Map()); // æ¸…ç©ºæ“ä½œï¼Œä¸éœ€è¦è¨˜æ†¶é«”ç®¡ç†
      setCurrentAssistantMessageId('');
    };

    window.addEventListener('projectChange', handleProjectChange);
    
    return () => {
      window.removeEventListener('projectChange', handleProjectChange);
    };
  }, []);

  const handleSendMessage = async () => {
    if (!inputValue.trim() && attachments.length === 0) return;
    if (!isAuthenticated) {
      message.error(t('chat.auth.error'));
      return;
    }


    // å»ºç«‹ä½¿ç”¨è€…è¨Šæ¯ (ä¿æŒåŸå§‹å…§å®¹)
    const newMessage: Message = {
      id: uuidv4(),
      role: 'user',
      content: inputValue.trim() || `[${t('chat.input.attachment')}]`,
      timestamp: new Date(),
      status: 'sending',
      attachments: [...attachments],
      currentFile: currentFile || undefined // å°‡æª”æ¡ˆè³‡è¨Šå„²å­˜åˆ°è¨Šæ¯ä¸­ï¼Œç”¨æ–¼é¡¯ç¤º
    };

    // ç™¼é€çµ¦ Claude çš„å…§å®¹åŒ…å«æª”æ¡ˆä¸Šä¸‹æ–‡
    let messageContent = inputValue.trim();
    if (currentFile) {
      // åªåœ¨ç™¼é€çµ¦ Claude æ™‚æ·»åŠ æª”æ¡ˆä¸Šä¸‹æ–‡ï¼Œä¸å½±éŸ¿ä½¿ç”¨è€…çœ‹åˆ°çš„å…§å®¹
      const fileContext = `\n\n[Context: Currently viewing ${currentFile.name} at ${currentFile.path}]`;
      messageContent = messageContent + fileContext;
    }
    const messageAttachments = [...fileInputRef.current];
    
    // å»ºç«‹å®Œæ•´çš„å°è©±æ­·å²ï¼ˆåŒ…å«æ–°è¨Šæ¯ï¼‰
    const updatedMessages = [...messages, newMessage];
    
    setMessages(updatedMessages);
    setInputValue('');
    setAttachments([]);
    fileInputRef.current = [];
    setIsLoading(true);
    setIsStreaming(true);
    setIsThinking(true);

    // æ¨™è¨˜å·²ç™¼é€ç¬¬ä¸€æ¬¡è¨Šæ¯
    if (!hasSentFirstMessage) {
      setHasSentFirstMessage(true);
    }

    // æº–å‚™æ¥æ”¶åŠ©ç†å›æ‡‰
    const assistantMessageId = uuidv4();
    setCurrentAssistantMessage('');
    setCurrentAssistantMessageId(assistantMessageId);

    try {
      const currentProject = getCurrentBasePath();
      
      if (!currentProject) {
        throw new Error(t('chat.error.project'));
      }

      // æ¨™è¨˜ç”¨æˆ¶è¨Šæ¯ç‚ºå·²ç™¼é€
      setMessages(prev => 
        prev.map(msg => 
          msg.id === newMessage.id ? { ...msg, status: 'sent' as const } : msg
        )
      );

      // ä½¿ç”¨ SSE ç™¼é€è¨Šæ¯ï¼Œå‚³å…¥ç€è¦½å™¨ç«¯çš„ session ID
      await claudeCodeService.sendMessageWithSSE(
        {
          content: messageContent,
          attachments: messageAttachments,
          projectPath: currentProject
          // ä¸éœ€è¦å‚³é€å°è©±æ­·å²ï¼ŒClaude SDK æœƒè‡ªå‹•ç®¡ç†
        },
        (event: StreamEvent) => {
          console.log('SSE Event:', event);

          switch (event.type) {
            case 'start':
              console.log('Query started:', (event.data as { message?: string })?.message);
              // ä¿æŒæ€è€ƒå‹•ç•«ï¼Œç›´åˆ°æ”¶åˆ°å¯¦éš›æ–‡å­—å›è¦†
              break;

            case 'session':
              // æ¥æ”¶ Claude SDK çš„çœŸå¯¦ session IDï¼Œå„²å­˜åˆ°ç€è¦½å™¨ç«¯
              const sessionData = event.data as { claudeSessionId?: string };
              if (sessionData?.claudeSessionId) {
                claudeSessionRef.current = sessionData.claudeSessionId;
                console.log('[ChatPanel] Received Claude session ID:', sessionData.claudeSessionId);
                // ä¸å†è¨­å®šåˆ° claudeCodeServiceï¼Œå› ç‚º session ID ç¾åœ¨ç”±ç€è¦½å™¨ç«¯ç®¡ç†
              }
              break;

            case 'message':
              const sdkMessage = (event.data as { data: SDKMessage })?.data;
              if (sdkMessage) {
                handleSDKMessage(sdkMessage, assistantMessageId);
              }
              break;

            case 'complete':
              // æª¢æŸ¥æ˜¯å¦ç‚ºå–æ¶ˆäº‹ä»¶
              if ((event.data as { cancelled?: boolean })?.cancelled) {
                console.log('Query cancelled by user');
                setIsStreaming(false);
                setIsThinking(false);
                
                // å¦‚æœæœ‰ç´¯ç©çš„è¨Šæ¯å…§å®¹ï¼Œæ¨™è¨˜ç‚ºå·²å–æ¶ˆ
                if (currentAssistantMessage.trim()) {
                  const cancelledMessage: Message = {
                    id: assistantMessageId,
                    role: 'assistant',
                    content: currentAssistantMessage,
                    timestamp: new Date(),
                    status: 'sent',
                    isCancelled: true
                  };
                  setMessages(prev => [...prev, cancelledMessage]);
                }
                
                // æ·»åŠ ç³»çµ±å–æ¶ˆè¨Šæ¯
                const systemMessage: Message = {
                  id: uuidv4(),
                  role: 'system',
                  content: t('chat.status.cancelledByUser', 'Cancelled by user'),
                  timestamp: new Date(),
                  status: 'sent'
                };
                setMessages(prev => [...prev, systemMessage]);
                setCurrentAssistantMessage('');
              } else {
                console.log('Query completed normally');
                setIsStreaming(false);
                setIsThinking(false);
                // å¦‚æœæœ‰ç´¯ç©çš„è¨Šæ¯å…§å®¹ï¼Œå»ºç«‹æœ€çµ‚è¨Šæ¯
                if (currentAssistantMessage.trim()) {
                  const finalMessage: Message = {
                    id: assistantMessageId,
                    role: 'assistant',
                    content: currentAssistantMessage,
                    timestamp: new Date(),
                    status: 'sent'
                  };
                  setMessages(prev => [...prev, finalMessage]);
                  setCurrentAssistantMessage('');
                }
              }
              break;

            case 'error':
              setIsStreaming(false);
              setIsThinking(false);
              
              // æ”¹å–„éŒ¯èª¤è™•ç†ï¼Œé¿å…é¡¯ç¤ºç©ºç‰©ä»¶
              let errorMsg = t('chat.error.unknown');
              const errorData = event.data as { error?: string | unknown };
              if (errorData?.error) {
                errorMsg = typeof errorData.error === 'string' ? errorData.error : t('chat.error.unknown');
              }
              
              // æª¢æŸ¥æ˜¯å¦ç‚ºå–æ¶ˆç›¸é—œçš„éŒ¯èª¤
              const isCancelledError = errorMsg.includes('cancelled') || 
                                     errorMsg.includes('aborted') || 
                                     errorMsg.includes('Request was cancelled') ||
                                     (event.data && typeof event.data === 'object' && event.data && Object.keys(event.data).length === 0); // ç©ºç‰©ä»¶é€šå¸¸è¡¨ç¤ºå–æ¶ˆ
              
              if (isCancelledError) {
                console.log('Request was cancelled or aborted');
                return;
              }
              
              // åªæœ‰éå–æ¶ˆéŒ¯èª¤æ‰è¨˜éŒ„å’Œé¡¯ç¤º
              console.error('[ChatPanel] Query failed:', {
                error: errorMsg,
                sessionId: claudeSessionRef.current,
                timestamp: new Date().toISOString()
              });
              message.error(`${t('chat.error.query')}: ${errorMsg || 'æœªçŸ¥éŒ¯èª¤'}`);
              break;
          }
        },
        claudeSessionRef.current // å‚³å…¥ç€è¦½å™¨ç«¯çš„ session ID
      );

    } catch (error) {
      console.error('[ChatPanel] Message send failed:', {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        sessionId: claudeSessionRef.current,
        messageLength: messageContent.length,
        timestamp: new Date().toISOString()
      });
      setIsStreaming(false);
      setIsThinking(false);
      setMessages(prev => 
        prev.map(msg => 
          msg.id === newMessage.id ? { ...msg, status: 'error' as const } : msg
        )
      );
      
      const errorMessage = error instanceof Error 
        ? `ç™¼é€å¤±æ•—: ${error.message}` 
        : `ç™¼é€å¤±æ•—: ${t('chat.error.send')}`;
      message.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // è™•ç†å–æ¶ˆè¨Šæ¯ç™¼é€
  const handleCancelMessage = () => {
    claudeCodeService.cancelCurrentRequest(claudeSessionRef.current);
    
    // å¦‚æœæœ‰æ­£åœ¨é€²è¡Œçš„åŠ©æ‰‹è¨Šæ¯ï¼Œå°‡å…¶æ¨™è¨˜ç‚ºå·²å–æ¶ˆ
    if (currentAssistantMessageId && (currentAssistantMessage.trim() || isThinking)) {
      const cancelledMessage: Message = {
        id: currentAssistantMessageId,
        role: 'assistant',
        content: currentAssistantMessage.trim() || '',
        timestamp: new Date(),
        status: 'sent',
        isCancelled: true
      };
      
      setMessages(prev => [...prev, cancelledMessage]);
      
      // æ·»åŠ ç³»çµ±å–æ¶ˆè¨Šæ¯
      const systemCancelMessage: Message = {
        id: uuidv4(),
        role: 'system',
        content: t('chat.status.cancelledByUser', 'Cancelled by user'),
        timestamp: new Date(),
        status: 'sent'
      };
      
      setMessages(prev => [...prev, systemCancelMessage]);
    } else {
      // å¦‚æœæ²’æœ‰æ­£åœ¨é€²è¡Œçš„æ¶ˆæ¯ï¼Œåªé¡¯ç¤ºå–æ¶ˆé€šçŸ¥
      message.info(t('chat.status.cancelled', 'å·²å–æ¶ˆè«‹æ±‚'));
    }
    
    // é‡ç½®æ‰€æœ‰ç‹€æ…‹
    setIsLoading(false);
    setIsStreaming(false);
    setIsThinking(false);
    setCurrentAssistantMessage('');
    setCurrentAssistantMessageId('');
    setToolActivities(new Map()); // æ¸…ç©ºæ“ä½œï¼Œä¸éœ€è¦è¨˜æ†¶é«”ç®¡ç†
  };

  // è™•ç† SDK è¨Šæ¯
  const handleSDKMessage = (sdkMessage: SDKMessage, assistantMessageId: string) => {
    switch (sdkMessage.type) {
      case 'assistant':
        // è™•ç†å·¥å…·ä½¿ç”¨
        if (sdkMessage.message.content && Array.isArray(sdkMessage.message.content)) {
          for (const contentItem of sdkMessage.message.content) {
            if (typeof contentItem === 'object' && contentItem.type === 'tool_use') {
              // æ·»åŠ æ–°çš„å·¥å…·æ´»å‹•
              const newActivity: ToolActivity = {
                toolName: contentItem.name,
                toolInput: contentItem.input,
                status: 'running',
                timestamp: new Date()
              };
              
              updateToolActivities(prev => {
                const current = prev.get(assistantMessageId) || [];
                const updated = new Map(prev);
                updated.set(assistantMessageId, [...current, newActivity]);
                return updated;
              });
            } else if (typeof contentItem === 'object' && contentItem.type === 'text') {
              // è™•ç†æ–‡å­—å…§å®¹ - ç•¶æ”¶åˆ°æ–‡å­—å…§å®¹æ™‚åœæ­¢æ€è€ƒå‹•ç•«
              if (contentItem.text) {
                setIsThinking(false);
                setCurrentAssistantMessage(prev => prev + contentItem.text);
              }
            }
          }
        } else if (typeof sdkMessage.message.content === 'string') {
          // ç•¶æ”¶åˆ°æ–‡å­—å…§å®¹æ™‚åœæ­¢æ€è€ƒå‹•ç•«
          setIsThinking(false);
          setCurrentAssistantMessage(prev => prev + sdkMessage.message.content);
        }
        break;
        
      case 'user':
        // æ›´æ–°å·¥å…·ç‹€æ…‹ç‚ºå·²å®Œæˆ
        if (sdkMessage.message.content && Array.isArray(sdkMessage.message.content)) {
          for (const contentItem of sdkMessage.message.content) {
            if (typeof contentItem === 'object' && contentItem.type === 'tool_result') {
              updateToolActivities(prev => {
                const current = prev.get(assistantMessageId) || [];
                const updated = new Map(prev);
                const newActivities = current.map(activity => {
                  // æ‰¾åˆ°å°æ‡‰çš„å·¥å…·æ´»å‹•ä¸¦æ›´æ–°ç‹€æ…‹
                  if (activity.status === 'running') {
                    return { ...activity, status: 'completed' as const };
                  }
                  return activity;
                });
                updated.set(assistantMessageId, newActivities);
                return updated;
              });
            }
          }
        }
        break;
        
      case 'result':
        if (sdkMessage.subtype === 'success') {
          const finalMessage: Message = {
            id: assistantMessageId,
            role: 'assistant',
            content: sdkMessage.result,
            timestamp: new Date(),
            status: 'sent'
          };
          setMessages(prev => [...prev, finalMessage]);
          setCurrentAssistantMessage('');
        } else {
          const errorMessage: Message = {
            id: uuidv4(),
            role: 'system',
            content: `${t('chat.error.execution')} ${sdkMessage.subtype}`,
            timestamp: new Date(),
            status: 'error'
          };
          setMessages(prev => [...prev, errorMessage]);
          
          // å°‡é€²è¡Œä¸­çš„å·¥å…·æ´»å‹•æ¨™è¨˜ç‚ºéŒ¯èª¤
          updateToolActivities(prev => {
            const current = prev.get(assistantMessageId) || [];
            const updated = new Map(prev);
            const newActivities = current.map(activity => {
              if (activity.status === 'running') {
                return { ...activity, status: 'error' as const };
              }
              return activity;
            });
            updated.set(assistantMessageId, newActivities);
            return updated;
          });
        }
        break;
        
      case 'system':
        console.log('System message:', sdkMessage);
        break;
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleFileUpload = (file: File) => {
    const attachment: FileAttachment = {
      id: uuidv4(),
      name: file.name,
      type: file.type,
      size: file.size
    };
    
    setAttachments(prev => [...prev, attachment]);
    fileInputRef.current.push(file);
    return false; // é˜»æ­¢è‡ªå‹•ä¸Šå‚³
  };

  const removeAttachment = (id: string) => {
    const attachmentIndex = attachments.findIndex(att => att.id === id);
    if (attachmentIndex !== -1) {
      // åŒæ™‚ç§»é™¤æª”æ¡ˆå¼•ç”¨
      fileInputRef.current.splice(attachmentIndex, 1);
    }
    setAttachments(prev => prev.filter(att => att.id !== id));
  };

  const panelStyle = {
    height: '100%',
    display: 'flex',
    flexDirection: 'column' as const,
    backgroundColor: darkMode ? '#1f1f1f' : '#fff',
    border: darkMode ? '1px solid #303030' : '1px solid #d9d9d9'
  };

  const headerStyle = {
    padding: '12px 16px',
    borderBottom: darkMode ? '1px solid #303030' : '1px solid #f0f0f0',
    backgroundColor: darkMode ? '#141414' : '#fafafa'
  };

  const messagesStyle = {
    flex: 1,
    overflow: 'auto',
    padding: '16px',
    backgroundColor: darkMode ? '#1a1a1a' : '#fafafa',
    fontFamily: 'Monaco, Consolas, "Courier New", monospace',
    fontSize: '14px'
  };

  const inputAreaStyle = {
    padding: '16px',
    borderTop: darkMode ? '1px solid #303030' : '1px solid #f0f0f0',
    backgroundColor: darkMode ? '#141414' : '#fafafa'
  };

  if (isAuthenticated === null) {
    return (
      <div style={panelStyle}>
        <div style={{ ...headerStyle, textAlign: 'center' }}>
          <Spin size="small" /> {t('chat.status.checking')}
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <div style={panelStyle}>
        <div style={headerStyle}>
          <span style={{ color: darkMode ? '#ff4d4f' : '#ff4d4f', fontSize: '14px' }}>
            âš  {t('chat.auth.required')}
          </span>
        </div>
        <div style={{ ...messagesStyle, textAlign: 'center', color: darkMode ? '#999' : '#666' }}>
          <p>{t('chat.auth.instruction')}</p>
          <code style={{ 
            backgroundColor: darkMode ? '#262626' : '#f5f5f5',
            padding: '4px 8px',
            borderRadius: '4px'
          }}>
            claude login
          </code>
        </div>
      </div>
    );
  }

  return (
    <div style={panelStyle} className={className}>
      {/* Header */}
      <div style={headerStyle}>
        <Space>
          <RobotOutlined style={{ color: darkMode ? '#52c41a' : '#52c41a' }} />
          <span style={{ fontWeight: 500, color: darkMode ? '#fff' : '#000' }}>
            Claude Code
          </span>
          <span
            style={{
              display: 'inline-block',
              width: '8px',
              height: '8px',
              borderRadius: '50%',
              backgroundColor: isAuthenticated ? '#52c41a' : '#ff4d4f', // ç¶ è‰²è¡¨ç¤ºå·²é€£æ¥ï¼Œç´…è‰²è¡¨ç¤ºæœªé€£æ¥
              cursor: 'pointer'
            }}
            title={isAuthenticated 
              ? (isStreaming ? t('chat.status.processing') : t('chat.status.ready'))
              : t('chat.auth.required')
            }
          />
        </Space>
      </div>

      {/* Messages Area */}
      <div style={messagesStyle}>
        <div style={{ display: 'flex', flexDirection: 'column' }}>
          {messages.map((message) => (
            <MessageBubble
              key={message.id}
              message={message}
              toolActivities={toolActivities.get(message.id)}
              darkMode={darkMode}
            />
          ))}

          {/* é¡¯ç¤º AI æ€è€ƒå‹•ç•« */}
          {isThinking && (
            <MessageBubble
              message={{
                id: 'thinking',
                role: 'assistant',
                content: '...',
                timestamp: new Date(),
                status: 'sending'
              }}
              darkMode={darkMode}
              isStreaming={true}
            />
          )}

          {/* é¡¯ç¤ºæ­£åœ¨ä¸²æµçš„åŠ©ç†è¨Šæ¯ */}
          {isStreaming && currentAssistantMessage && !isThinking && (
            <MessageBubble
              message={{
                id: currentAssistantMessageId,
                role: 'assistant',
                content: currentAssistantMessage,
                timestamp: new Date(),
                status: 'sending'
              }}
              toolActivities={toolActivities.get(currentAssistantMessageId)}
              darkMode={darkMode}
              isStreaming={true}
            />
          )}
        </div>
        <div ref={messagesEndRef} />
      </div>

      {/* Input Area */}
      <div style={inputAreaStyle}>
        {/* Current File Indicator */}
        {currentFile && (
          <div style={{
            marginBottom: '8px',
            padding: '6px 12px',
            backgroundColor: darkMode ? '#1a1a1a' : '#f0f8ff',
            borderLeft: `3px solid ${darkMode ? '#1890ff' : '#1890ff'}`,
            borderRadius: '4px',
            fontSize: '12px',
            display: 'flex',
            alignItems: 'center',
            gap: '8px'
          }}>
            <span style={{ 
              color: darkMode ? '#1890ff' : '#1890ff',
              fontWeight: '500'
            }}>
              ğŸ“„ {t('chat.fileContext.current')}
            </span>
            <span style={{ 
              color: darkMode ? '#e6e6e6' : '#333',
              fontFamily: 'Monaco, Consolas, "Courier New", monospace'
            }}>
              {currentFile.name}
            </span>
            <Button 
              type="text" 
              size="small"
              onClick={() => setCurrentFile(null)}
              style={{ 
                padding: '0 4px', 
                marginLeft: 'auto',
                color: darkMode ? '#888' : '#666'
              }}
              title={t('chat.fileContext.clear')}
            >
              Ã—
            </Button>
          </div>
        )}

        {/* Attachments Preview */}
        {attachments.length > 0 && (
          <div style={{ marginBottom: '8px' }}>
            {attachments.map(att => (
              <div key={att.id} style={{
                display: 'inline-flex',
                alignItems: 'center',
                padding: '4px 8px',
                backgroundColor: darkMode ? '#262626' : '#f5f5f5',
                borderRadius: '4px',
                marginRight: '8px',
                fontSize: '12px'
              }}>
                <span style={{ color: darkMode ? '#e6e6e6' : '#000' }}>ğŸ“ {att.name}</span>
                <Button 
                  type="text" 
                  size="small" 
                  onClick={() => removeAttachment(att.id)}
                  style={{ padding: '0 4px', marginLeft: '4px' }}
                >
                  Ã—
                </Button>
              </div>
            ))}
          </div>
        )}

        <Space.Compact style={{ width: '100%' }}>
          <TextArea
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={t('chat.input.placeholder')}
            autoSize={{ minRows: 1, maxRows: 4 }}
            style={{ 
              flex: 1,
              backgroundColor: darkMode ? '#1f1f1f' : '#fff',
              borderColor: darkMode ? '#303030' : '#d9d9d9',
              color: darkMode ? '#fff' : '#000',
              resize: 'none'
            }}
            disabled={isLoading}
          />
          {/* æª”æ¡ˆä¸Šå‚³åŠŸèƒ½æš«æ™‚éš±è— - è©³è¦‹ TODO.md Feature #3 */}
          {false && (
            <Upload
              beforeUpload={handleFileUpload}
              showUploadList={false}
              multiple
            >
              <Button 
                icon={<PaperClipOutlined />} 
                disabled={isLoading}
                style={{
                  backgroundColor: darkMode ? '#262626' : '#f5f5f5',
                  borderColor: darkMode ? '#303030' : '#d9d9d9',
                  color: darkMode ? '#fff' : '#000'
                }}
              />
            </Upload>
          )}
          <Button 
            type="primary" 
            icon={isLoading ? <CloseOutlined /> : <SendOutlined />}
            onClick={isLoading ? handleCancelMessage : handleSendMessage}
            loading={false}
            disabled={!isLoading && (!inputValue.trim() && attachments.length === 0)}
            title={isLoading ? t('chat.action.cancel', 'å–æ¶ˆ') : t('chat.action.send', 'ç™¼é€')}
          />
        </Space.Compact>
        
        {/* è¼¸å…¥æç¤º */}
        <div style={{
          marginTop: '4px',
          fontSize: '11px',
          color: darkMode ? '#888' : '#999',
          textAlign: 'center'
        }}>
          {t('chat.input.shortcut')}
        </div>
        
        {/* Session ID */}
        <div style={{
          marginTop: '4px',
          marginBottom: '-12px',
          fontSize: '8px',
          color: darkMode ? '#666' : '#aaa',
          textAlign: 'center',
          fontFamily: 'Monaco, Consolas, "Courier New", monospace',
          // fontStyle: 'italic'
        }}>
          {claudeSessionRef.current ? (
            <>SESSION-ID: {claudeSessionRef.current}</>
          ) : (
            <>&nbsp;</> // ä¿ç•™ç©ºé–“ä½†ä¸é¡¯ç¤ºå…§å®¹ï¼Œç›´åˆ°ç²å¾—çœŸå¯¦ session ID
          )}
        </div>
      </div>
    </div>
  );
};

export default ChatPanel;
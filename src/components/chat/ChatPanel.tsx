"use client";

import React, { useState, useRef, useEffect, useCallback } from "react";
import { Input, Button, Space, Upload, Spin, App } from "antd";
import {
  SendOutlined,
  PaperClipOutlined,
  RobotOutlined,
  CloseOutlined,
} from "@ant-design/icons";
import { useTranslation } from "react-i18next";
import { v4 as uuidv4 } from "uuid";
import { Message, FileAttachment, CurrentFileInfo } from "@/lib/types/chat";
import claudeCodeService, {
  type StreamEvent,
} from "@/lib/services/claudeCodeService";
import { useProject } from "@/lib/providers/project-provider";
import type { SDKMessage } from "@anthropic-ai/claude-code";
import MessageBubble, { type ToolActivity } from "./MessageBubble";

const { TextArea } = Input;

interface ChatPanelProps {
  darkMode?: boolean;
  className?: string;
}

// Remove duplicate definition, use imported CurrentFileInfo directly

export const ChatPanel: React.FC<ChatPanelProps> = ({
  darkMode = false,
  className,
}) => {
  const { t } = useTranslation();
  const { getCurrentBasePath } = useProject();
  const { message } = App.useApp();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [attachments, setAttachments] = useState<FileAttachment[]>([]);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);
  const [currentAssistantMessage, setCurrentAssistantMessage] =
    useState<string>("");
  const [isStreaming, setIsStreaming] = useState(false);
  const [isThinking, setIsThinking] = useState(false);
  const [toolActivities, setToolActivities] = useState<
    Map<string, ToolActivity[]>
  >(new Map());

  // Tool Activities memory management configuration
  const MAX_TOOL_ACTIVITIES_SIZE = 50; // Maximum 50 messages' tool activities retained
  const CLEANUP_THRESHOLD = 60; // Trigger cleanup when exceeding 60

  // Cleanup Tool Activities memory
  const cleanupToolActivities = useCallback(
    (currentMap: Map<string, ToolActivity[]>) => {
      if (currentMap.size <= MAX_TOOL_ACTIVITIES_SIZE) {
        return currentMap;
      }

      // Convert to array and sort by timestamp (keep newest)
      const entries = Array.from(currentMap.entries());
      const sortedEntries = entries.sort((a, b) => {
        const aLatestTime = Math.max(
          ...a[1].map((activity) => activity.timestamp.getTime()),
        );
        const bLatestTime = Math.max(
          ...b[1].map((activity) => activity.timestamp.getTime()),
        );
        return bLatestTime - aLatestTime; // Descending order, newest first
      });

      // Keep only the newest MAX_TOOL_ACTIVITIES_SIZE entries
      const keptEntries = sortedEntries.slice(0, MAX_TOOL_ACTIVITIES_SIZE);
      const cleanedMap = new Map(keptEntries);

      console.log(
        `[ChatPanel] Cleaned tool activities: ${currentMap.size} â†’ ${cleanedMap.size}`,
      );
      return cleanedMap;
    },
    [MAX_TOOL_ACTIVITIES_SIZE],
  );

  // Safe Tool Activities update function (with memory management)
  const updateToolActivities = useCallback(
    (
      updater: (
        prev: Map<string, ToolActivity[]>,
      ) => Map<string, ToolActivity[]>,
    ) => {
      setToolActivities((prev) => {
        const updated = updater(prev);

        // Check if cleanup is needed
        if (updated.size >= CLEANUP_THRESHOLD) {
          return cleanupToolActivities(updated);
        }

        return updated;
      });
    },
    [CLEANUP_THRESHOLD, cleanupToolActivities],
  );
  const [currentAssistantMessageId, setCurrentAssistantMessageId] =
    useState<string>("");
  const [currentFile, setCurrentFile] = useState<CurrentFileInfo | null>(null);
  const [hasSentFirstMessage, setHasSentFirstMessage] = useState(false); // Track if first message has been sent
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<File[]>([]);
  const claudeSessionRef = useRef<string | null>(null); // Store Claude SDK's actual session ID

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, currentAssistantMessage]);

  // Initialize conversation history and load historical messages
  useEffect(() => {
    const initializeChat = async () => {
      const currentProject = getCurrentBasePath();
      if (currentProject) {
        // In new architecture, each page load automatically creates new isolated session
        // Session ID is generated dynamically by Claude SDK, no need to pre-generate
        console.log("[ChatPanel] Initialize with new architecture");
        console.log(
          "[ChatPanel] Session ID will be generated by Claude SDK on first query",
        );
        console.log(
          "[ChatPanel] Each tab/reload automatically creates isolated session",
        );

        // Initialize with empty message history, let new conversation start fresh
        setMessages([]);

        // Cleanup sessionStorage items no longer needed
        sessionStorage.removeItem("pageRefreshed");
        sessionStorage.removeItem("isNewWindow");
        sessionStorage.removeItem("windowId");
      }
    };

    initializeChat();
  }, [getCurrentBasePath]);

  // Listen to file selection events from parent window
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Check message source and type
      if (event.data?.type === "fileSelected" && event.data?.file) {
        const fileInfo = event.data.file as CurrentFileInfo;
        setCurrentFile(fileInfo);
        console.log("[ChatPanel] Received file selection:", fileInfo.path);
      }
    };

    // Listen to postMessage events
    window.addEventListener("message", handleMessage);

    // Cleanup listener
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, []);

  // Check authentication status
  useEffect(() => {
    const checkAuth = async () => {
      const authStatus = await claudeCodeService.checkAuthentication();
      setIsAuthenticated(authStatus);
    };
    checkAuth();
  }, []);

  // Listen to project switch events, clear conversation content
  useEffect(() => {
    const handleProjectChange = () => {
      setMessages([]);
      setCurrentAssistantMessage("");
      setIsStreaming(false);
      setIsThinking(false);
      setToolActivities(new Map()); // Clear operation, no memory management needed
      setCurrentAssistantMessageId("");
    };

    window.addEventListener("projectChange", handleProjectChange);

    return () => {
      window.removeEventListener("projectChange", handleProjectChange);
    };
  }, []);

  const handleSendMessage = async () => {
    if (!inputValue.trim() && attachments.length === 0) return;
    if (!isAuthenticated) {
      message.error(t("chat.auth.error"));
      return;
    }

    // Create user message (preserve original content)
    const newMessage: Message = {
      id: uuidv4(),
      role: "user",
      content: inputValue.trim() || `[${t("chat.input.attachment")}]`,
      timestamp: new Date(),
      status: "sending",
      attachments: [...attachments],
      currentFile: currentFile || undefined, // Store file information in message for display
    };

    // Content sent to Claude includes file context
    let messageContent = inputValue.trim();
    if (currentFile) {
      // Add file context only when sending to Claude, without affecting user-visible content
      const fileContext = `\n\n[Context: Currently viewing ${currentFile.name} at ${currentFile.path}]`;
      messageContent = messageContent + fileContext;
    }
    const messageAttachments = [...fileInputRef.current];

    // Build complete conversation history (including new message)
    const updatedMessages = [...messages, newMessage];

    setMessages(updatedMessages);
    setInputValue("");
    setAttachments([]);
    fileInputRef.current = [];
    setIsLoading(true);
    setIsStreaming(true);
    setIsThinking(true);

    // Mark that first message has been sent
    if (!hasSentFirstMessage) {
      setHasSentFirstMessage(true);
    }

    // Prepare to receive assistant response
    const assistantMessageId = uuidv4();
    setCurrentAssistantMessage("");
    setCurrentAssistantMessageId(assistantMessageId);

    try {
      const currentProject = getCurrentBasePath();

      if (!currentProject) {
        throw new Error(t("chat.error.project"));
      }

      // Mark user message as sent
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === newMessage.id ? { ...msg, status: "sent" as const } : msg,
        ),
      );

      // Send message using SSE, passing browser-side session ID
      await claudeCodeService.sendMessageWithSSE(
        {
          content: messageContent,
          attachments: messageAttachments,
          projectPath: currentProject,
          // No need to send conversation history, Claude SDK manages it automatically
        },
        (event: StreamEvent) => {
          console.log("SSE Event:", event);

          switch (event.type) {
            case "start":
              console.log(
                "Query started:",
                (event.data as { message?: string })?.message,
              );
              // Keep thinking animation until actual text response is received
              break;

            case "session":
              // Receive actual session ID from Claude SDK and store it on browser side
              const sessionData = event.data as { claudeSessionId?: string };
              if (sessionData?.claudeSessionId) {
                claudeSessionRef.current = sessionData.claudeSessionId;
                console.log(
                  "[ChatPanel] Received Claude session ID:",
                  sessionData.claudeSessionId,
                );
                // No longer set to claudeCodeService, as session ID is now managed by browser side
              }
              break;

            case "message":
              const sdkMessage = (event.data as { data: SDKMessage })?.data;
              if (sdkMessage) {
                handleSDKMessage(sdkMessage, assistantMessageId);
              }
              break;

            case "complete":
              // Check if this is a cancel event
              if ((event.data as { cancelled?: boolean })?.cancelled) {
                console.log("Query cancelled by user");
                setIsStreaming(false);
                setIsThinking(false);

                // If there is accumulated message content, mark it as cancelled
                if (currentAssistantMessage.trim()) {
                  const cancelledMessage: Message = {
                    id: assistantMessageId,
                    role: "assistant",
                    content: currentAssistantMessage,
                    timestamp: new Date(),
                    status: "sent",
                    isCancelled: true,
                  };
                  setMessages((prev) => [...prev, cancelledMessage]);
                }

                // Add system cancellation message
                const systemMessage: Message = {
                  id: uuidv4(),
                  role: "system",
                  content: t(
                    "chat.status.cancelledByUser",
                    "Cancelled by user",
                  ),
                  timestamp: new Date(),
                  status: "sent",
                };
                setMessages((prev) => [...prev, systemMessage]);
                setCurrentAssistantMessage("");
              } else {
                console.log("Query completed normally");
                setIsStreaming(false);
                setIsThinking(false);
                // If there is accumulated message content, create final message
                if (currentAssistantMessage.trim()) {
                  const finalMessage: Message = {
                    id: assistantMessageId,
                    role: "assistant",
                    content: currentAssistantMessage,
                    timestamp: new Date(),
                    status: "sent",
                  };
                  setMessages((prev) => [...prev, finalMessage]);
                  setCurrentAssistantMessage("");
                }
              }
              break;

            case "error":
              setIsStreaming(false);
              setIsThinking(false);

              // Improve error handling to avoid displaying empty objects
              let errorMsg = t("chat.error.unknown");
              const errorData = event.data as { error?: string | unknown };
              if (errorData?.error) {
                errorMsg =
                  typeof errorData.error === "string"
                    ? errorData.error
                    : t("chat.error.unknown");
              }

              // Check if this is a cancellation-related error
              const isCancelledError =
                errorMsg.includes("cancelled") ||
                errorMsg.includes("aborted") ||
                errorMsg.includes("Request was cancelled") ||
                (event.data &&
                  typeof event.data === "object" &&
                  event.data &&
                  Object.keys(event.data).length === 0); // Empty object usually indicates cancellation

              if (isCancelledError) {
                console.log("Request was cancelled or aborted");
                return;
              }

              // Only log and display non-cancellation errors
              console.error("[ChatPanel] Query failed:", {
                error: errorMsg,
                sessionId: claudeSessionRef.current,
                timestamp: new Date().toISOString(),
              });
              message.error(
                `${t("chat.error.query")}: ${errorMsg || "Unknown error"}`,
              );
              break;
          }
        },
        claudeSessionRef.current, // Pass browser-side session ID
      );
    } catch (error) {
      console.error("[ChatPanel] Message send failed:", {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        sessionId: claudeSessionRef.current,
        messageLength: messageContent.length,
        timestamp: new Date().toISOString(),
      });
      setIsStreaming(false);
      setIsThinking(false);
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === newMessage.id ? { ...msg, status: "error" as const } : msg,
        ),
      );

      const errorMessage =
        error instanceof Error
          ? `Send failed: ${error.message}`
          : `Send failed: ${t("chat.error.send")}`;
      message.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle message send cancellation
  const handleCancelMessage = () => {
    claudeCodeService.cancelCurrentRequest(claudeSessionRef.current);

    // If there is an ongoing assistant message, mark it as cancelled
    if (
      currentAssistantMessageId &&
      (currentAssistantMessage.trim() || isThinking)
    ) {
      const cancelledMessage: Message = {
        id: currentAssistantMessageId,
        role: "assistant",
        content: currentAssistantMessage.trim() || "",
        timestamp: new Date(),
        status: "sent",
        isCancelled: true,
      };

      setMessages((prev) => [...prev, cancelledMessage]);

      // Add system cancellation message
      const systemCancelMessage: Message = {
        id: uuidv4(),
        role: "system",
        content: t("chat.status.cancelledByUser", "Cancelled by user"),
        timestamp: new Date(),
        status: "sent",
      };

      setMessages((prev) => [...prev, systemCancelMessage]);
    } else {
      // If there is no ongoing message, just show cancellation notification
      message.info(t("chat.status.cancelled", "å·²å–æ¶ˆè«‹æ±‚"));
    }

    // Reset all states
    setIsLoading(false);
    setIsStreaming(false);
    setIsThinking(false);
    setCurrentAssistantMessage("");
    setCurrentAssistantMessageId("");
    setToolActivities(new Map()); // Clear operations, no memory management needed
  };

  // Handle SDK messages
  const handleSDKMessage = (
    sdkMessage: SDKMessage,
    assistantMessageId: string,
  ) => {
    switch (sdkMessage.type) {
      case "assistant":
        // Handle tool usage
        if (
          sdkMessage.message.content &&
          Array.isArray(sdkMessage.message.content)
        ) {
          for (const contentItem of sdkMessage.message.content) {
            if (
              typeof contentItem === "object" &&
              contentItem.type === "tool_use"
            ) {
              // Add new tool activity
              const newActivity: ToolActivity = {
                toolName: contentItem.name,
                toolInput: contentItem.input,
                status: "running",
                timestamp: new Date(),
              };

              updateToolActivities((prev) => {
                const current = prev.get(assistantMessageId) || [];
                const updated = new Map(prev);
                updated.set(assistantMessageId, [...current, newActivity]);
                return updated;
              });
            } else if (
              typeof contentItem === "object" &&
              contentItem.type === "text"
            ) {
              // Handle text content - stop thinking animation when text content is received
              if (contentItem.text) {
                setIsThinking(false);
                setCurrentAssistantMessage((prev) => prev + contentItem.text);
              }
            }
          }
        } else if (typeof sdkMessage.message.content === "string") {
          // Stop thinking animation when text content is received
          setIsThinking(false);
          setCurrentAssistantMessage(
            (prev) => prev + sdkMessage.message.content,
          );
        }
        break;

      case "user":
        // Update tool status to completed
        if (
          sdkMessage.message.content &&
          Array.isArray(sdkMessage.message.content)
        ) {
          for (const contentItem of sdkMessage.message.content) {
            if (
              typeof contentItem === "object" &&
              contentItem.type === "tool_result"
            ) {
              updateToolActivities((prev) => {
                const current = prev.get(assistantMessageId) || [];
                const updated = new Map(prev);
                const newActivities = current.map((activity) => {
                  // Find corresponding tool activity and update status
                  if (activity.status === "running") {
                    return { ...activity, status: "completed" as const };
                  }
                  return activity;
                });
                updated.set(assistantMessageId, newActivities);
                return updated;
              });
            }
          }
        }
        break;

      case "result":
        if (sdkMessage.subtype === "success") {
          const finalMessage: Message = {
            id: assistantMessageId,
            role: "assistant",
            content: sdkMessage.result,
            timestamp: new Date(),
            status: "sent",
          };
          setMessages((prev) => [...prev, finalMessage]);
          setCurrentAssistantMessage("");
        } else {
          const errorMessage: Message = {
            id: uuidv4(),
            role: "system",
            content: `${t("chat.error.execution")} ${sdkMessage.subtype}`,
            timestamp: new Date(),
            status: "error",
          };
          setMessages((prev) => [...prev, errorMessage]);

          // Mark ongoing tool activities as error
          updateToolActivities((prev) => {
            const current = prev.get(assistantMessageId) || [];
            const updated = new Map(prev);
            const newActivities = current.map((activity) => {
              if (activity.status === "running") {
                return { ...activity, status: "error" as const };
              }
              return activity;
            });
            updated.set(assistantMessageId, newActivities);
            return updated;
          });
        }
        break;

      case "system":
        console.log("System message:", sdkMessage);
        break;
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleFileUpload = (file: File) => {
    const attachment: FileAttachment = {
      id: uuidv4(),
      name: file.name,
      type: file.type,
      size: file.size,
    };

    setAttachments((prev) => [...prev, attachment]);
    fileInputRef.current.push(file);
    return false; // Prevent automatic upload
  };

  const removeAttachment = (id: string) => {
    const attachmentIndex = attachments.findIndex((att) => att.id === id);
    if (attachmentIndex !== -1) {
      // Also remove file reference
      fileInputRef.current.splice(attachmentIndex, 1);
    }
    setAttachments((prev) => prev.filter((att) => att.id !== id));
  };

  const panelStyle = {
    height: "100%",
    display: "flex",
    flexDirection: "column" as const,
    backgroundColor: darkMode ? "#1f1f1f" : "#fff",
    border: darkMode ? "1px solid #303030" : "1px solid #d9d9d9",
  };

  const headerStyle = {
    padding: "12px 16px",
    borderBottom: darkMode ? "1px solid #303030" : "1px solid #f0f0f0",
    backgroundColor: darkMode ? "#141414" : "#fafafa",
  };

  const messagesStyle = {
    flex: 1,
    overflow: "auto",
    padding: "16px",
    backgroundColor: darkMode ? "#1a1a1a" : "#fafafa",
    fontFamily: 'Monaco, Consolas, "Courier New", monospace',
    fontSize: "14px",
  };

  const inputAreaStyle = {
    padding: "16px",
    borderTop: darkMode ? "1px solid #303030" : "1px solid #f0f0f0",
    backgroundColor: darkMode ? "#141414" : "#fafafa",
  };

  if (isAuthenticated === null) {
    return (
      <div style={panelStyle}>
        <div style={{ ...headerStyle, textAlign: "center" }}>
          <Spin size="small" /> {t("chat.status.checking")}
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <div style={panelStyle}>
        <div style={headerStyle}>
          <span
            style={{
              color: darkMode ? "#ff4d4f" : "#ff4d4f",
              fontSize: "14px",
            }}
          >
            âš  {t("chat.auth.required")}
          </span>
        </div>
        <div
          style={{
            ...messagesStyle,
            textAlign: "center",
            color: darkMode ? "#999" : "#666",
          }}
        >
          <p>{t("chat.auth.instruction")}</p>
          <code
            style={{
              backgroundColor: darkMode ? "#262626" : "#f5f5f5",
              padding: "4px 8px",
              borderRadius: "4px",
            }}
          >
            claude login
          </code>
        </div>
      </div>
    );
  }

  return (
    <div style={panelStyle} className={className}>
      {/* Header */}
      <div style={headerStyle}>
        <Space>
          <RobotOutlined style={{ color: darkMode ? "#52c41a" : "#52c41a" }} />
          <span style={{ fontWeight: 500, color: darkMode ? "#fff" : "#000" }}>
            Claude Code
          </span>
          <span
            style={{
              display: "inline-block",
              width: "8px",
              height: "8px",
              borderRadius: "50%",
              backgroundColor: isAuthenticated ? "#52c41a" : "#ff4d4f", // Green indicates connected, red indicates not connected
              cursor: "pointer",
            }}
            title={
              isAuthenticated
                ? isStreaming
                  ? t("chat.status.processing")
                  : t("chat.status.ready")
                : t("chat.auth.required")
            }
          />
        </Space>
      </div>

      {/* Messages Area */}
      <div style={messagesStyle}>
        <div style={{ display: "flex", flexDirection: "column" }}>
          {messages.map((message) => (
            <MessageBubble
              key={message.id}
              message={message}
              toolActivities={toolActivities.get(message.id)}
              darkMode={darkMode}
            />
          ))}

          {/* Display AI thinking animation */}
          {isThinking && (
            <MessageBubble
              message={{
                id: "thinking",
                role: "assistant",
                content: "...",
                timestamp: new Date(),
                status: "sending",
              }}
              darkMode={darkMode}
              isStreaming={true}
            />
          )}

          {/* Display streaming assistant message */}
          {isStreaming && currentAssistantMessage && !isThinking && (
            <MessageBubble
              message={{
                id: currentAssistantMessageId,
                role: "assistant",
                content: currentAssistantMessage,
                timestamp: new Date(),
                status: "sending",
              }}
              toolActivities={toolActivities.get(currentAssistantMessageId)}
              darkMode={darkMode}
              isStreaming={true}
            />
          )}
        </div>
        <div ref={messagesEndRef} />
      </div>

      {/* Input Area */}
      <div style={inputAreaStyle}>
        {/* Current File Indicator */}
        {currentFile && (
          <div
            style={{
              marginBottom: "8px",
              padding: "6px 12px",
              backgroundColor: darkMode ? "#1a1a1a" : "#f0f8ff",
              borderLeft: `3px solid ${darkMode ? "#1890ff" : "#1890ff"}`,
              borderRadius: "4px",
              fontSize: "12px",
              display: "flex",
              alignItems: "center",
              gap: "8px",
            }}
          >
            <span
              style={{
                color: darkMode ? "#1890ff" : "#1890ff",
                fontWeight: "500",
              }}
            >
              ðŸ“„ {t("chat.fileContext.current")}
            </span>
            <span
              style={{
                color: darkMode ? "#e6e6e6" : "#333",
                fontFamily: 'Monaco, Consolas, "Courier New", monospace',
              }}
            >
              {currentFile.name}
            </span>
            <Button
              type="text"
              size="small"
              onClick={() => setCurrentFile(null)}
              style={{
                padding: "0 4px",
                marginLeft: "auto",
                color: darkMode ? "#888" : "#666",
              }}
              title={t("chat.fileContext.clear")}
            >
              Ã—
            </Button>
          </div>
        )}

        {/* Attachments Preview */}
        {attachments.length > 0 && (
          <div style={{ marginBottom: "8px" }}>
            {attachments.map((att) => (
              <div
                key={att.id}
                style={{
                  display: "inline-flex",
                  alignItems: "center",
                  padding: "4px 8px",
                  backgroundColor: darkMode ? "#262626" : "#f5f5f5",
                  borderRadius: "4px",
                  marginRight: "8px",
                  fontSize: "12px",
                }}
              >
                <span style={{ color: darkMode ? "#e6e6e6" : "#000" }}>
                  ðŸ“Ž {att.name}
                </span>
                <Button
                  type="text"
                  size="small"
                  onClick={() => removeAttachment(att.id)}
                  style={{ padding: "0 4px", marginLeft: "4px" }}
                >
                  Ã—
                </Button>
              </div>
            ))}
          </div>
        )}

        <Space.Compact style={{ width: "100%" }}>
          <TextArea
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={t("chat.input.placeholder")}
            autoSize={{ minRows: 1, maxRows: 4 }}
            style={{
              flex: 1,
              backgroundColor: darkMode ? "#1f1f1f" : "#fff",
              borderColor: darkMode ? "#303030" : "#d9d9d9",
              color: darkMode ? "#fff" : "#000",
              resize: "none",
            }}
            disabled={isLoading}
          />
          {/* File upload feature temporarily hidden - See TODO.md Feature #3 */}
          {false && (
            <Upload
              beforeUpload={handleFileUpload}
              showUploadList={false}
              multiple
            >
              <Button
                icon={<PaperClipOutlined />}
                disabled={isLoading}
                style={{
                  backgroundColor: darkMode ? "#262626" : "#f5f5f5",
                  borderColor: darkMode ? "#303030" : "#d9d9d9",
                  color: darkMode ? "#fff" : "#000",
                }}
              />
            </Upload>
          )}
          <Button
            type="primary"
            icon={isLoading ? <CloseOutlined /> : <SendOutlined />}
            onClick={isLoading ? handleCancelMessage : handleSendMessage}
            loading={false}
            disabled={
              !isLoading && !inputValue.trim() && attachments.length === 0
            }
            title={
              isLoading
                ? t("chat.action.cancel", "å–æ¶ˆ")
                : t("chat.action.send", "ç™¼é€")
            }
          />
        </Space.Compact>

        {/* Input hint */}
        <div
          style={{
            marginTop: "4px",
            fontSize: "11px",
            color: darkMode ? "#888" : "#999",
            textAlign: "center",
          }}
        >
          {t("chat.input.shortcut")}
        </div>

        {/* Session ID */}
        <div
          style={{
            marginTop: "4px",
            marginBottom: "-12px",
            fontSize: "8px",
            color: darkMode ? "#666" : "#aaa",
            textAlign: "center",
            fontFamily: 'Monaco, Consolas, "Courier New", monospace',
            // fontStyle: 'italic'
          }}
        >
          {claudeSessionRef.current ? (
            <>SESSION-ID: {claudeSessionRef.current}</>
          ) : (
            <>&nbsp;</> // Reserve space but don't display content until actual session ID is obtained
          )}
        </div>
      </div>
    </div>
  );
};

export default ChatPanel;
